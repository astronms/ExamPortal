{"ast":null,"code":"import { __decorate, __param, __metadata } from 'tslib';\nimport { InjectionToken, Inject, Injectable, Optional, SkipSelf, NgModule } from '@angular/core';\nimport { mergeMap } from 'rxjs/operators';\nimport { parse } from 'url';\nimport { from } from 'rxjs';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport * as ɵngcc0 from '@angular/core';\nconst JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\nlet JwtHelperService = /*#__PURE__*/(() => {\n  let JwtHelperService = class JwtHelperService {\n    constructor(config = null) {\n      this.tokenGetter = config && config.tokenGetter || function () {};\n    }\n\n    urlBase64Decode(str) {\n      let output = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n      switch (output.length % 4) {\n        case 0:\n          {\n            break;\n          }\n\n        case 2:\n          {\n            output += \"==\";\n            break;\n          }\n\n        case 3:\n          {\n            output += \"=\";\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"Illegal base64url string!\");\n          }\n      }\n\n      return this.b64DecodeUnicode(output);\n    } // credits for decoder goes to https://github.com/atk\n\n\n    b64decode(str) {\n      const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n      let output = \"\";\n      str = String(str).replace(/=+$/, \"\");\n\n      if (str.length % 4 === 1) {\n        throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n      }\n\n      for ( // initialize result and counters\n      let bc = 0, bs, buffer, idx = 0; // get next character\n      buffer = str.charAt(idx++); // character found in table? initialize bit storage and add its ascii value;\n      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n      bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {\n        // try to find character in table (0-63, not found => -1)\n        buffer = chars.indexOf(buffer);\n      }\n\n      return output;\n    }\n\n    b64DecodeUnicode(str) {\n      return decodeURIComponent(Array.prototype.map.call(this.b64decode(str), c => {\n        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\n      }).join(\"\"));\n    }\n\n    decodeToken(token = this.tokenGetter()) {\n      if (!token || token === \"\") {\n        return null;\n      }\n\n      const parts = token.split(\".\");\n\n      if (parts.length !== 3) {\n        throw new Error(\"The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.\");\n      }\n\n      const decoded = this.urlBase64Decode(parts[1]);\n\n      if (!decoded) {\n        throw new Error(\"Cannot decode the token.\");\n      }\n\n      return JSON.parse(decoded);\n    }\n\n    getTokenExpirationDate(token = this.tokenGetter()) {\n      let decoded;\n      decoded = this.decodeToken(token);\n\n      if (!decoded || !decoded.hasOwnProperty(\"exp\")) {\n        return null;\n      }\n\n      const date = new Date(0);\n      date.setUTCSeconds(decoded.exp);\n      return date;\n    }\n\n    isTokenExpired(token = this.tokenGetter(), offsetSeconds) {\n      if (!token || token === \"\") {\n        return true;\n      }\n\n      const date = this.getTokenExpirationDate(token);\n      offsetSeconds = offsetSeconds || 0;\n\n      if (date === null) {\n        return false;\n      }\n\n      return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n    }\n\n    getAuthScheme(authScheme, request) {\n      if (typeof authScheme === \"function\") {\n        return authScheme(request);\n      }\n\n      return authScheme;\n    }\n\n  };\n\n  JwtHelperService.ɵfac = function JwtHelperService_Factory(t) {\n    return new (t || JwtHelperService)(ɵngcc0.ɵɵinject(JWT_OPTIONS));\n  };\n\n  JwtHelperService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: JwtHelperService,\n    factory: function (t) {\n      return JwtHelperService.ɵfac(t);\n    }\n  });\n  JwtHelperService = __decorate([__param(0, Inject(JWT_OPTIONS)), __metadata(\"design:paramtypes\", [Object])], JwtHelperService);\n  return JwtHelperService;\n})();\nlet JwtInterceptor = /*#__PURE__*/(() => {\n  let JwtInterceptor = class JwtInterceptor {\n    constructor(config, jwtHelper) {\n      this.jwtHelper = jwtHelper;\n      this.standardPorts = [\"80\", \"443\"];\n      this.tokenGetter = config.tokenGetter;\n      this.headerName = config.headerName || \"Authorization\";\n      this.authScheme = config.authScheme || config.authScheme === \"\" ? config.authScheme : \"Bearer \";\n      this.whitelistedDomains = config.whitelistedDomains || [];\n      this.blacklistedRoutes = config.blacklistedRoutes || [];\n      this.throwNoTokenError = config.throwNoTokenError || false;\n      this.skipWhenExpired = config.skipWhenExpired;\n    }\n\n    isWhitelistedDomain(request) {\n      const requestUrl = parse(request.url, false, true);\n      const hostName = requestUrl.hostname !== null ? `${requestUrl.hostname}${requestUrl.port && !this.standardPorts.includes(requestUrl.port) ? \":\" + requestUrl.port : \"\"}` : requestUrl.hostname;\n      return hostName === null || this.whitelistedDomains.findIndex(domain => typeof domain === \"string\" ? domain === hostName : domain instanceof RegExp ? domain.test(hostName) : false) > -1;\n    }\n\n    isBlacklistedRoute(request) {\n      const requestedUrl = parse(request.url, false, true);\n      return this.blacklistedRoutes.findIndex(route => {\n        if (typeof route === \"string\") {\n          const parsedRoute = parse(route, false, true);\n          return parsedRoute.hostname === requestedUrl.hostname && parsedRoute.path === requestedUrl.path;\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1;\n    }\n\n    handleInterception(token, request, next) {\n      const authScheme = this.jwtHelper.getAuthScheme(this.authScheme, request);\n      let tokenIsExpired = false;\n\n      if (!token && this.throwNoTokenError) {\n        throw new Error(\"Could not get token from tokenGetter function.\");\n      }\n\n      if (this.skipWhenExpired) {\n        tokenIsExpired = token ? this.jwtHelper.isTokenExpired(token) : true;\n      }\n\n      if (token && tokenIsExpired && this.skipWhenExpired) {\n        request = request.clone();\n      } else if (token) {\n        request = request.clone({\n          setHeaders: {\n            [this.headerName]: `${authScheme}${token}`\n          }\n        });\n      }\n\n      return next.handle(request);\n    }\n\n    intercept(request, next) {\n      if (!this.isWhitelistedDomain(request) || this.isBlacklistedRoute(request)) {\n        return next.handle(request);\n      }\n\n      const token = this.tokenGetter(request);\n\n      if (token instanceof Promise) {\n        return from(token).pipe(mergeMap(asyncToken => {\n          return this.handleInterception(asyncToken, request, next);\n        }));\n      } else {\n        return this.handleInterception(token, request, next);\n      }\n    }\n\n  };\n\n  JwtInterceptor.ɵfac = function JwtInterceptor_Factory(t) {\n    return new (t || JwtInterceptor)(ɵngcc0.ɵɵinject(JWT_OPTIONS), ɵngcc0.ɵɵinject(JwtHelperService));\n  };\n\n  JwtInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: JwtInterceptor,\n    factory: function (t) {\n      return JwtInterceptor.ɵfac(t);\n    }\n  });\n  JwtInterceptor = __decorate([__param(0, Inject(JWT_OPTIONS)), __metadata(\"design:paramtypes\", [Object, JwtHelperService])], JwtInterceptor);\n  return JwtInterceptor;\n})();\nvar JwtModule_1;\n;\nlet JwtModule = JwtModule_1 = class JwtModule {\n  constructor(parentModule) {\n    if (parentModule) {\n      throw new Error(\"JwtModule is already loaded. It should only be imported in your application's main module.\");\n    }\n  }\n\n  static forRoot(options) {\n    return {\n      ngModule: JwtModule_1,\n      providers: [{\n        provide: HTTP_INTERCEPTORS,\n        useClass: JwtInterceptor,\n        multi: true\n      }, options.jwtOptionsProvider || {\n        provide: JWT_OPTIONS,\n        useValue: options.config\n      }, JwtHelperService]\n    };\n  }\n\n};\n\nJwtModule.ɵfac = function JwtModule_Factory(t) {\n  return new (t || JwtModule)(ɵngcc0.ɵɵinject(JwtModule, 12));\n};\n\nJwtModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n  type: JwtModule\n});\nJwtModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n\nJwtModule.ctorParameters = () => [{\n  type: JwtModule,\n  decorators: [{\n    type: Optional\n  }, {\n    type: SkipSelf\n  }]\n}];\n\nJwtModule = JwtModule_1 = __decorate([__param(0, Optional()), __param(0, SkipSelf()), __metadata(\"design:paramtypes\", [JwtModule])], JwtModule);\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Public API Surface of angular-jwt\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { JWT_OPTIONS, JwtHelperService, JwtInterceptor, JwtModule }; //# sourceMappingURL=auth0-angular-jwt.js.map","map":null,"metadata":{},"sourceType":"module"}